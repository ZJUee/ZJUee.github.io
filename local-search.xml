<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件</title>
    <link href="/2024/04/10/CS_learning/C/%E6%96%87%E4%BB%B6/"/>
    <url>/2024/04/10/CS_learning/C/%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h2><p>保留在外储存器的一组数据的有序组合，C语言中文件是字节流</p><p>特点：</p><ul><li>数据长久保存</li><li>数据长度不定</li><li>数据按顺序存取</li></ul><h2 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h2><p>标准I&#x2F;O库中定义了三个特殊的标识符：</p><ol><li>stdin 标准输入：终端键盘</li><li>stdout 标准输出：终端显示器</li><li>stderr 标准出错：终端显示器</li></ol><p>三个标准文件在操作系统启动时自动打开，在系统关闭时关闭，器件不允许应用关闭他们</p><p>这三个标识符作为FILE*常量可以被所有程序使用</p><h2 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h2><p>文本文件：ASCII文件,一个字节存储一个ascii代码（一个ASCII码用8位二进制小数存储）</p><p>1BYTE&#x3D;8bit（bit&#x3D;一位二进制小数）<br>1024BYTE&#x3D;1KB（诸如此类网上递增）</p><p>二进制文件：把内存中的数据按照内存的存储形式原样输出到磁盘上存放</p><p>所以表示相同的数字，文本文件需要的空间更大，处理花费时间多。但是便于逐个对字符进行处理</p><p>二进制文件可以节省外存空间和转换时间，但是一个字节不对应一个字符，不能直接输出字符样式</p><p>一般中间结果数据暂时保存在外存上，以后又需要输入内存的，常用未禁止文件保存</p><h2 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h2><p>由于直接把文件写在外存上效率低下，我们设置了缓冲区</p><p>由程序控制数据进入缓冲区，再由‘操作系统自己跌完成文件储存</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><p>系统不自动开辟确定大小的缓冲区，而由程序为每个文件设定缓冲区<br>用非缓冲区系统进行文件系统进行的输入和输出</p><p>又称为低级输入输出系统</p><p>在UNIX系统中，用缓冲文件系统来处理文本文件，用非缓冲文件系统来处理二进制文件</p><h2 id="ansi-c对文件的处理方法"><a href="#ansi-c对文件的处理方法" class="headerlink" title="ansi c对文件的处理方法"></a>ansi c对文件的处理方法</h2><p>采用缓冲文件系统来处理文本文件和二进制文件<br>C语言中对文件的读写都是由库函数来实现的<br>头文件:&lt;stdio.h&gt;</p><p>向外输出数据：数据库—&gt;缓冲区——&gt;装满缓冲区之后——&gt;磁盘文件</p><p>向外存读取数据：一次性从磁盘中收取一批数据库到缓冲区—–&gt;然后再从缓冲区逐个输入读取数据到程序变量</p><h2 id="文件类型指针"><a href="#文件类型指针" class="headerlink" title="文件类型指针"></a>文件类型指针</h2><p>用文件指针表示文件缓冲区</p><p>FILE *fp<br>在缓冲文件系统中，每个被使用的文件都要在内存中开辟一个FILE类文件型的缓冲区，存放文件有关的信息。<br>同时使用多个文件时，每一个文件都有缓冲区，用不同的文件指针分别指向</p><p>FILE  *fp；fp是一个<strong>指向FILE类型结构体</strong>的指针变量。<br>可以使fp指向某一个文件的结构体变量，从而通过该结构体变量中的文件信息能够访问该文件。</p><p>如果有ｎ个文件，一般应设ｎ个指针变量，使它们分别指向n个文件，以实现对文件的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">short</span>      level;  <span class="hljs-comment">/* 缓冲区使用量  */</span><br>    <span class="hljs-type">unsigned</span>      flags;  <span class="hljs-comment">/* 文件状态标志 */</span><br>    <span class="hljs-type">char</span>       fd;     <span class="hljs-comment">/* 文件描述符 */</span><br>    <span class="hljs-type">short</span>       size; <span class="hljs-comment">/* 缓冲区大小 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   *buffer;   <span class="hljs-comment">/* 文件缓冲区的首地址 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>    *curp;     <span class="hljs-comment">/* 指向文件缓冲区的工作指针 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   hold;      <span class="hljs-comment">/* 其他信息 */</span><br>    <span class="hljs-type">unsigned</span>      istemp;         <br>    <span class="hljs-type">short</span>       oken;          <br>&#125; FILE;<br><br></code></pre></td></tr></table></figure><p>如何使fp和一个具体文件挂钩：</p><p>专门的文件操作函数用于打开、读取、写入和关闭文件，这些函数通常会返回一个文件指针，你可以使用这个文件指针来进行后续的文件操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *fp; <span class="hljs-comment">// 声明一个文件指针</span><br>    <span class="hljs-type">char</span> filename[] = <span class="hljs-string">&quot;example.txt&quot;</span>; <span class="hljs-comment">// 文件名</span><br><br>    <span class="hljs-comment">// 打开文件，如果文件不存在则创建新文件，以只写方式打开</span><br>    fp = fopen(filename, <span class="hljs-string">&quot;w&quot;</span>);<br><br>    <span class="hljs-comment">// 检查文件是否成功打开</span><br>    <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法打开文件 %s\n&quot;</span>, filename);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 写入数据到文件</span><br>    <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;Hello, world!\n&quot;</span>);<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    fclose(fp);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，通过 fopen 函数打开一个名为 “example.txt” 的文件，并指定以只写方式打开。<em>fopen 函数会返回一个文件指针</em>，<br>该文件指针被赋值给变量 fp。</p><p>然后，使用 fprintf 函数将字符串 “Hello, world!\n” 写入到文件中。</p><p>最后，使用 fclose 函数关闭文件。</p><p>这样，文件指针 fp 就与文件 “example.txt” 被挂钩了，</p><p>可以使用 fp 变量来对该文件进行后续的读写操作。</p><h3 id="文件打开"><a href="#文件打开" class="headerlink" title="文件打开"></a>文件打开</h3><p>在C语言中，<code>fopen</code> 函数用于打开文件，并且可以指定不同的模式（方式）来进行文件的读写操作。以下是 <code>fopen</code> 函数常用的文件打开方式：</p><ol><li><code>&quot;r&quot;</code>：只读模式。文件必须存在，否则会打开失败。文件指针被放置在文件的开头。</li><li><code>&quot;w&quot;</code>：写入模式。如果文件不存在，则创建新文件；如果文件已存在，则清空文件内容。文件指针被放置在文件的开头。</li><li><code>&quot;a&quot;</code>：追加模式。如果文件不存在，则创建新文件；如果文件已存在，则在文件末尾追加内容。文件指针被放置在文件的末尾。</li><li><code>&quot;r+&quot;</code>：读写模式。文件必须存在，否则会打开失败。文件指针被放置在文件的开头。</li><li><code>&quot;w+&quot;</code>：读写模式。如果文件不存在，则创建新文件；如果文件已存在，则清空文件内容。文件指针被放置在文件的开头。</li><li><code>&quot;a+&quot;</code>：读写模式。如果文件不存在，则创建新文件；如果文件已存在，则在文件末尾追加内容。文件指针被放置在文件的末尾。</li></ol><p>在这些模式中，”+” 表示文件可以读取和写入。例如，”r+” 允许读取和写入文件，而 “w+” 允许读取和写入文件，如果文件不存在则创建新文件，如果文件已存在则清空文件内容。</p><p>文件打开使得文件实体和文件指针对应起来</p><ol><li>可以在外存中找到这个文件</li><li>在内存开辟了一个512字节的缓冲区，并且有fp指向文件缓冲区起始位置</li><li>把首块512字节数据：从外存—&gt;缓冲区</li></ol><p>检查命令行参数：exit（）函数关闭打开的所有文件并且结束程序，正常结束的程序传递是0，异常结束的程序传递非0值(即使在别的函数中，exit()也能直接结束整个程序)</p><h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><ol><li>字符读函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *FP)</span><br></code></pre></td></tr></table></figure><ol start="2"><li>字符串读函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span> n, FILE *fp)</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li>格式化读函数:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *format, …)</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li>二进制(块)读函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(<span class="hljs-type">char</span> buffer, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> count,  FILE *fp)</span>;<br></code></pre></td></tr></table></figure><p>把数据写到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">-字符写函数：<span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> c, FILE *fp)</span>;<br>-字符串写函数： <span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">int</span> n, FILE *fo)</span>;<br>-格式化写函数：<span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE *fp, <span class="hljs-type">char</span> *format, …)</span>;<br>-二进制(块)写函数：<br><span class="hljs-type">int</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> count, FILE *fp)</span>;<br></code></pre></td></tr></table></figure><h4 id="主要关注fputc-和fgetc-两个"><a href="#主要关注fputc-和fgetc-两个" class="headerlink" title="主要关注fputc()和fgetc()两个"></a>主要关注fputc()和fgetc()两个</h4><p>fputc()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch,FILE *fp)</span>;<br></code></pre></td></tr></table></figure><p>功能：把一个字符ch，输入到文件流中</p><ol><li>成功：返回写入的值</li><li>失败：返回EOF</li></ol><p>fgetc()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *fp)</span>;<br></code></pre></td></tr></table></figure><p>功能：从文件流取出下一个字节并且把他作为一个字符返回，如果达到文件结尾或者出现错误返回EOF</p><h4 id="fgets-fputs"><a href="#fgets-fputs" class="headerlink" title="fgets() &amp;&amp; fputs()"></a>fgets() &amp;&amp; fputs()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> n, FILE *fp)</span>;<span class="hljs-comment">//函数原型</span><br></code></pre></td></tr></table></figure><p>功能：从fp所指的文件中读入字符并存到参数buf（buf需要自己定义一个数组？）所指的内存空间，直到出现换行字符、读到文件尾或是已读了n-1个字符<br><em>读取n-1个字符，不是n个，读完n-1个字符的时候，不管buf是否存满，都不再读取</em></p><p>buf是一个字符串，最后会加上\0作为字符串结束（注意，字符串储存在字符串数组里）<br>返回值 ：若成功则返回buf指针，返回NULL则表示有错误发生。</p><p>使用时注意以下几点：</p><ol><li>当遇到换行符或者缓冲区已满，fgets就会停止，返回读到的数据，值得注意的是不能用fgets读二进制文件，因为fgets会把二进制文件当成文本文件来处理，这势必会产生乱码。</li><li>每次调用，fgets都会把缓冲区的最后一个字符设为’\0’，这意味着最后一个字符不能用来存放需要的数据，所以<strong>如果有一行，含有LINE_SIZE个字符(包括换行符)，要想把这行读入缓冲区，请把参数n设为LINE_SIZE+1</strong></li><li>由结论1可推出：给定参数n，fgets只能读取n-1个字符(包括换行符)，如果有一行超过n-1个字符，那么fgets返回一个不完整的行，也就是说，只读取该行的前n-1个字符，但是，<strong>缓冲区总是以null字符结尾，对fgets的下一次调用会继续读该行。</strong></li></ol><h4 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h4>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C语言</tag>
      
      <tag>文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>勾芡日记</title>
    <link href="/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E5%8B%BE%E8%8A%A1%E6%97%A5%E8%AE%B0/"/>
    <url>/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E5%8B%BE%E8%8A%A1%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>勾芡是一种植物，可惜我高三才发现这并不是传统的植物<br>后来应该被做成了扫把，叫什么伽程扫，我也没见过，听说有人见过，那有和我什么关系呢？</p><p>—-JimmyEastBrook</p><h2 id="正传"><a href="#正传" class="headerlink" title="正传"></a>正传</h2>]]></content>
    
    
    
    <tags>
      
      <tag>回忆录</tag>
      
      <tag>勾芡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>骇客传</title>
    <link href="/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E9%AA%87%E5%AE%A2%E4%BC%A0/"/>
    <url>/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E9%AA%87%E5%AE%A2%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>骇客是我高中第一任班主任，但其实他早就是僵尸了<br>呵呵，我也差点成为僵尸了，好险。</p><p>—-JimmyEastBrook</p><h2 id="骇客曾经的名字叫慧根"><a href="#骇客曾经的名字叫慧根" class="headerlink" title="骇客曾经的名字叫慧根"></a>骇客曾经的名字叫慧根</h2>]]></content>
    
    
    
    <tags>
      
      <tag>回忆录</tag>
      
      <tag>骇客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苏子语录</title>
    <link href="/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E8%8B%8F%E5%AD%90%E8%AF%AD%E5%BD%95/"/>
    <url>/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E8%8B%8F%E5%AD%90%E8%AF%AD%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>苏素作为玉环中学作业第一多的神仙，我们都忘不掉她。<br>同时，不要忘记她是狱中少数没有变成僵尸的神仙。</p><p>—-JimmyEastBrook</p><h2 id="苏子语录正文"><a href="#苏子语录正文" class="headerlink" title="苏子语录正文"></a>苏子语录正文</h2><p>待编辑</p>]]></content>
    
    
    
    <tags>
      
      <tag>回忆录</tag>
      
      <tag>苏素</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被人忽略的规则</title>
    <link href="/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E8%A2%AB%E4%BA%BA%E5%BF%BD%E7%95%A5%E7%9A%84%E8%A7%84%E5%88%99/"/>
    <url>/2024/04/10/%E7%8B%B1%E4%B8%AD%E5%BE%80%E4%BA%8B/%E8%A2%AB%E4%BA%BA%E5%BF%BD%E7%95%A5%E7%9A%84%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<p>尚待建设<br>大家集思广益啊</p>]]></content>
    
    
    
    <tags>
      
      <tag>回忆录</tag>
      
      <tag>规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git_note</title>
    <link href="/2024/04/10/CS_learning/git/git_note/"/>
    <url>/2024/04/10/CS_learning/git/git_note/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始学习《github入门与实战》</p><p>1.GitHub 是为开发者提供 Git 仓库的托管服务。这是一个让开发者与<br>朋友、同事、同学及陌生人共享代码的完美场所</p><p>2.在 Git 中，开发者将源代码存入名叫“Git 仓库”的资料库中<br>并加以使用。而 GitHub 则是在网络上提供 Git 仓库的一项服务</p><p>3.Pull Request 是指开发者在本地对源代码进行更改后，向 GitHub 中托管的 Git 仓库请求合并的功能。</p><p>4.GitHub 快捷的环境为开发者带来的合作伙伴，并不只局限于自己团队内部。只要将感兴趣的仓库添加至 Watch 中，就可以在 News Feed 查看该仓库的相关信息</p><h2 id="Git的导入"><a href="#Git的导入" class="headerlink" title="Git的导入"></a>Git的导入</h2><p>1.Git 属于分散型版本管理系统，是为版本管理而设计的软件<br>2.集中型仓库<br>集中型将所有数据集中存放在服务器当中，有便于管理的优点。<br>但是一旦开发者所处的环境不能连接服务器，就无法获取最新的源代码，<br>开发也就几乎无法进行。服务器宕机时也是同样的道理，而且万一服务器故障导致数据消失，恐怕开发者就再也见不到最新的源代码了。</p><p>3.分散型仓库（git）<br>GitHub 将仓库 Fork 给了每一个用户。<br>Fork 就是将 GitHub 的某个特定仓库复制到自己的账户下。Fork 出的仓库与原仓库是两个不同的仓库，开发者可以随意编辑。</p><p>好处：分散型拥有多个仓库，相对而言稍显复杂。<br>由于本地的开发环境中就有仓库，所以开发者不必连接远程仓库就可以进行<br>开发。</p><h2 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h2><p>1.设置SSHkey</p><p>SSH Key：secure shell key 安全外壳秘钥<br>用于安全访问远程服务器的加密密钥对<br>通常由私钥和公钥两个部分组成，被用于进行身份验证和加密通讯</p><p>私钥：私钥通常保存在你的计算机上，并且必须严格保密。它用于对传出的数据进行签名和对传入的数据进行解密。私钥相当于你的身份证，用来证明你是谁。</p><p>公钥：公钥是私钥的对应部分，可以公开分享。它被存储在你要访问的远程服务器上。远程服务器使用公钥验证与之通信的客户端的身份，并将数据加密后发送给客户端。公钥相当于你的访问卡，别人通过它来确认你的身份。</p><p>SSH密钥对通常用于以下场景：</p><p>远程登录（SSH登录）：使用SSH密钥对可以免密码登录远程服务器，提高登录的安全性。</p><p>Git和其他版本控制系统：SSH密钥对也可以用于身份验证，允许你与代码仓库进行安全通信，比如通过SSH连接到Git仓库。</p><p>安全文件传输：SSH密钥对也可以用于加密和解密文件的传输，保证数据的安全性。</p><p>id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥</p><p>当你第一次通过SSH连接到一个新的主机时，你的SSH客户端会询问你是否信任这个新的主机 这是因为SSH客户端无法确定这个新的主机是否是你期望连接的那个主机，还是一个试图冒充你期望连接的主机的恶意主机。</p><p>在这个过程中，SSH客户端会显示新主机的公钥指纹，并询问你是否要继续连接。如果你输入”yes”，那么你的SSH客户端将会把这个新主机的公钥指纹添加到known_hosts文件中，并且在以后的连接中不再询问你是否信任这个主机。</p><p>所以，当你看到这个提示，并且你确认你正在连接到你期望的主机时，你可以输入”yes”来继续连接。但是，请注意，你应该只在你确认你正在连接到你期望的主机时输入”yes”，如果你有任何疑虑，你应该检查这个新主机的公钥指纹，或者联系你的系统管理员</p><h3 id="使用社区功能和实际动手使用"><a href="#使用社区功能和实际动手使用" class="headerlink" title="使用社区功能和实际动手使用"></a>使用社区功能和实际动手使用</h3><p>1.Follow别人<br>2.创建仓库<br>(1)New repository</p><p>(2)初始设置</p><p>在 Repository name 栏中输入仓库的名称</p><p>Description 栏中可以设置仓库的说明。这一栏不是必需项，可以留空。</p><p>在 Initialize this repository with a README 选项上打钩，随后GitHub 会自动初始化仓库并设置 README 文件，让用户可以立刻clone 这个仓库。如果想向 GitHub 添加手中已有的 Git 仓库，建议不要<br>勾选，直接手动 push</p><p>(3)README</p><p>README.md 在初始化时已经生成好了。README.md 文件的内容会自动显示在仓库的首页当中</p><p>3.公开代码</p><p>(1)clone已有的代码</p><p>git clone ———–(此处填写ssh clone URL)</p><p>此时会被要求输入自己的密码</p><p>然后就可以把存储在github上的仓库克隆到自己这里</p><p>(2)自己把一份文件拉倒自己的仓库地址</p><p>然后输入git status查看状态</p><p>使用git add +文件名称（需要后缀）——-加入缓存区</p><p>使用git commit -m “加入自己关于这次更新的解释”——提交文件</p><p>使用git log查看提交日志</p><p>使用git push更新github上的仓库</p><h2 id="深入使用git"><a href="#深入使用git" class="headerlink" title="深入使用git"></a>深入使用git</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>git init ——初始化仓库</p><p>在 Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。<br>文件的编辑等操作在工作树中进行，然后记录到仓库中，以此管理文件的历史快照。如果想将文件恢复到原先的状态，可以从仓库中调取之前的快照，在工作树中打开。开发者可以通过这种方式获取以往的文件。具体操作指令我们将在后面详细解说。</p><p>git status———查看仓库的状态</p><p>commit：提交，指记录工作树中所有文件的当前状态</p><p>尚没有可提交的内容，就是说当前我们建立的这个仓库中还没有记录任何文件的任何状态</p><p>git add——向暂存区添加文件</p><p>要想让文件成为 Git 仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。</p><p><em>补充几个概念</em><br><strong>工作区（Working Directory）就是你在电脑里能看到的目录，比如你的项目文件夹就是一个工作区。工作区里有一个隐藏的 .git 文件夹，这就是Git的版本库（Repository）</strong></p><p><strong>工作树（Working Tree）是工作区里的一部分，它是Git跟踪和管理的文件的实际内容。工作树中的文件可以是未跟踪的（untracked），已跟踪的（tracked），已修改的（modified），已暂存的（staged）等状态。</strong></p><p><strong>git仓库的工作树是文件夹，而不是 .git 文件。.git 文件是版本库，它存储了Git的元数据和对象数据库，包括暂存区、分支、标签、HEAD等信息。</strong></p><p>git commit——把暂存区的文件保存到仓库号的历史记录中同时记录自己的评论留言</p><p>通过历史记录我们可以从工作树中复原文件</p><p>-m 参数后的 “First commit”称作提交信息，是对这个提交的<br>概述。</p><p>如果想要记述得更加详细，请不加 - m，直接执行 g i t c o m m i t命令。执行后编辑器就会启<br>动，并显示如下结果</p><p>&#x2F;# Please enter the commit message for your changes. Lines starting<br>&#x2F;# with ‘#’ will be ignored, and an empty message aborts the commit.<br>&#x2F;# On branch master<br>&#x2F;#<br>&#x2F;# Initial commit</p><p>在编辑器中记述提交信息的格式如下。<br>● 第一行：用一行文字简述提交的更改内容<br>● 第二行：空行<br>● 第三行以后：记述更改的原因和详细内容</p><p>在以 #（井号）标为注释的 Changes to be committed（要提<br>交的更改）栏中，可以查看本次提交中包含的文件。将提交信息按格式记述完毕后，请保存并关闭编辑器，以 #（井号）标为注释的行不必删除。随后，刚才记述的提交信息就会被提交</p><p><strong>如果在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止。</strong></p><p>git log——查看提交日志</p><p>commit 栏旁边显示的“9f129b……”是指向这个提交的哈希值</p><p>Author 栏中显示我们给 Git 设置的用户名和邮箱地址。Date 栏中显示提交执行的日期和时间。再往下就是该提交的提交信息</p><p><em>如果只想让程序显示第一行简述信息，可以在 git log命令后加上 –pretty&#x3D;short。这样一来开发人员就能够更轻松地把握多个提交。</em></p><p><em>只显示指定目录、文件的日志只要在 git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。</em><br><em>如果想查看提交所带来的改动，可以加上 - p参数，文件的前后差别就会显示在提交信息之后</em></p><p>git log命令可以利用多种参数帮助开发者把握以往<br>提交的内容。不必勉强自己一次记下全部参数，每当有想查看的日志就<br>积极去查，慢慢就能得心应手了。</p><p>git diff —–查看工作树，暂存区，最新提交之间的差别</p><p>这里解释一下显示的内容。“+”号标出的是新添加的行，被删除的行则用“-”号标出。</p><p>不妨养成这样一个好习惯：在执行 git commit命令之前先执行<br>git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的 HEAD 是指向当前分支中最新一次提<br>交的指针</p><h3 id="分支的操作"><a href="#分支的操作" class="headerlink" title="分支的操作"></a>分支的操作</h3><p>并行作业的时候会用到分支。在这类并行开发的过程中，往往同时存在多个最新代码状态。不同分支中，可以同时进行完全不同的作业。等该分支的作业完成之后再与 master 分支合并。</p><p><strong>git branch——–显示分支一览表</strong><br><strong>git checkout -b——-创建切换分支</strong><br><strong>git checkout -b &lt;分支名字&gt;</strong></p><p>实际上，连续执行两条命令也能收到同样的效果：<br><strong>$git branch <name></strong><br>$git checkout name ——创建A分支同时切换到A分支下</p><p>不断对分支的操作，我们叫做“培育分支”<br>git checkout name—可以切换到想要的分支</p><p>在main里我添加一个feature-A分支，feature-A分支中我改动了readme文件，但是在main分支中的readme文件并未被更改，这就是创建分支的优点，只要创建分支，就能在不影响的情况下同时进行多个功能的开发</p><p>git checkout -（切换回上一个分支）</p><p>特性分支：集中实现单一特性（主题），除此以外不进行任何作业的分支。在日常开发中往往会创建数个特性分支，同时保留一个随时可以发布软件的稳定分支。<br>稳定分支的角色通常由master担当</p><p>我们开发了feature-A分支，这个分支只实现feature-A的功能，如果开发过程中出现了bug，我们就再创建新的分支，在新分支中修复</p><p>基于特定主题的作业在特性分支中进行，主题完成以后再与master分支合并。只要保持一个开发流程，就能保证master分支可以随时供人查看。这样其他开发者也可以大胆从master分支中创建新的特性分支</p><p>主干分支是刚才我们讲解的特性分支的原点，同时也是合并的终点。通常人们会用 master 分支作为主干分支。主干分支中并没有开发到一半的代码，可以随时供他人查看。<br>有时我们需要让这个主干分支总是配置在正式环境中，有时又需要用标签 Tag 等创建版本信息，同时管理多个版本发布。拥有多个版本发布时，主干分支也有多个。</p><p>git merge——合并分支<br>假设我的featu-A分支已经实现完毕，想要将他合并到主干分支master中，首先要切换到master分支中<br>git checkout master<br>Switched to branch ‘master’<br>然后合并 feature-A 分支。为了在历史记录中明确记录下本次分支合<br>并，我们需要创建合并提交。因此，在合并时加上 –no-ff参数。<br>$ git merge –no-ff feature-A<br>随后编辑器会启动，用于录入合并提交的信息。</p><p>默认信息中已经包含了是从 feature-A 分支合并过来的相关内容，所<br>以可不必做任何更改。将编辑器中显示的内容保存，关闭编辑器，然后就会看到下面的结果</p><p><strong>git log –graph</strong>用于以图表的形式查看分支</p><h3 id="更改提交的操作"><a href="#更改提交的操作" class="headerlink" title="更改提交的操作"></a>更改提交的操作</h3><h4 id="git-reset————回溯历史版本"><a href="#git-reset————回溯历史版本" class="headerlink" title="git reset————回溯历史版本"></a>git reset————回溯历史版本</h4><p>Git 的一大特征便是可以灵活操作历史版本。借助分散仓库的优势，可以在不影响其他仓库的前提下对历史版本进行操作。</p><p><strong>如何回溯</strong>：<br>1.回溯到对应状态<br>要让仓库的HEAD，暂存区，当前工作树回溯的制定的状态，就需要用<strong>git reset –hard</strong>指令</p><p>只要提供目标时间点的哈希值，就可以完全恢复到该时间点的状态</p><p>git reset –hard  哈希值<br>之后就可以成功回溯到特征分支创建之前的状态，由于所有的文件都已经回溯到制定哈希值对应的时间点上，README.md文件也恢复到了当时的状态</p><p>2.使用fix-B<br>git checkout -b fix-B————创建并进入到fix-B分支中</p><p>然后修复一些我们想要修复的bug<br>3.推进到feature-A分支合并后的状态：”推进历史”</p><p>git log 命令只能查看当前状态为终点的历史日志<br>git reflog可以查看当前仓库的操作日志，在日志中找出回溯历史之前的哈希值，找出回溯历史之前的哈希值，通过git reset –hard命令恢复到回溯历史之前的状态。</p><p>在日志中，我们可以看到 commit、checkout、reset、merge 等 Git 命令的执行记录。只要不进行 Git 的 GC（Garbage Collection，垃圾回收），就可以通过日志随意调取近期的历史状态，就像给时间机器指定一个时间点，在过去未来中自由穿梭一般。即便开发者错误执行了 Git 操作，基本也都可以利用 git reflog命令恢复到原先的状态</p><p>如果我们有多个版本时，我们最后都是要进行版本融合。在不同版本之间相同地方有不同的内容的话会引发冲突，这个时候就要消除冲突。</p><p><strong>消除版本冲突就是去相应文件修改，然后重新提交一份</strong>，这样之后会显示 Fix conflict</p><p>git commmit –amend（修改提交信息）：也就是修改注释。</p><p>将对应部分修改之后保存文件然后关闭编辑器就可以显示上面的修改结果。执行git log -graph就可以看到相应的提交内容</p><p>git rebase -i  压缩历史</p><p>在合并特性分支之前，如果发现已提交的内容中有些许拼写错误等，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录。这样可以避开最新版本的错误，使用前面版本的正确代码。</p><p>*<em>错字漏字等失误称作typo，所以我们将提交信息记为”Fix  typo”</em></p><h2 id="（跳一步，学4-6以后的内容）"><a href="#（跳一步，学4-6以后的内容）" class="headerlink" title="（跳一步，学4.6以后的内容）"></a>（跳一步，学4.6以后的内容）</h2><p>Pro Git&#x2F;LearningGitBranch&#x2F;tryGit&#x2F;(书中给的几份资料)</p><h2 id="github的功能"><a href="#github的功能" class="headerlink" title="github的功能"></a>github的功能</h2><h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><p>shift + &#x2F; 打开键盘快捷键一览表，查看当前页面的快捷键</p><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><h4 id="关于UI"><a href="#关于UI" class="headerlink" title="关于UI"></a>关于UI</h4><p>工具栏常驻于各个页面的上端,用就会了</p><p>explore：介绍Github上的热门软件<br>1.github公司特别介绍的软件<br>2.按语言筛选热门仓库的开发者（是汉语不是计算机语言）</p><p>gist：管理没必要保存在仓库的代码（小的代码片段：随便编写的脚本代码都可以放进去）（gist上添加的代码示例可以嵌入到博客中，选择了语言还会自动添加高亮）</p><p>blog：github中官方博客的超链接，github公司会在上面发布通知</p><p>help：github上相关的帮助</p><p>account setting:设置账户页面，个人信息，安全管理，付费方案的设置</p><h4 id="仓库的UI"><a href="#仓库的UI" class="headerlink" title="仓库的UI"></a>仓库的UI</h4><p>code：文件列表（仓库名下方是该仓库的简单说明和URL）<br>wiki：一种比HTML更简单的页面描述功能，记录开发者之间应该共享的信息和软件文档，当前数字表示Wiki的页面数量<br>graphs：图标表示仓库的各种指标<br>pluse：仓库最近的活动信息（看看这个软件是否热门）<br>network：显示出当前仓库的状态和fork出的仓库的状态<br>SSH clone URL：clone 仓库时所需的 URL。点击右侧的剪贴板图标可以将 URL 复制到剪贴板中。点击 HTTPS、SSH、Subversion 图标可以切换至相应协议的 URL</p><p>issue：<br>先指定语言再描述代码</p><p>就可以做到语法高亮，让代码变得直观已易读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>在issue栏添加图片也很方便，直接把图片拖拽到这个文本框里就好了<br><em>添加标签</em><br>issue可以通过标签label来整理，添加标签后issue左侧就会显示标签，点击页面左侧的标签就可以只显示该类别的标签。</p><p>标签可以自由创建，可以按照语言和技术分类，也可以按照整理bug，任务和备忘等类别来分类。</p><p>除了标签，还可以添加里程碑来管理任务</p><h4 id="tasklist语法"><a href="#tasklist语法" class="headerlink" title="tasklist语法"></a>tasklist语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Tasklist">- [] 完成图片<br>- [] 完成部署工具<br>- [] 完成抽签功能<br></code></pre></td></tr></table></figure><p>这样就会被描述成复选列表的格式，这样的复选列表可以直接勾选或取消勾选，不必打开issue的页面重新编辑</p>]]></content>
    
    
    <categories>
      
      <category>CS_learning</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/10/hello-world/"/>
    <url>/2024/04/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
